---
layout: post
title: "Readable Concepts"
modified:
categories: 
excerpt:
tags: [c++]
image:
  feature:
date: 2015-08-01T02:05:16+02:00
---

Before [the acceptance of Concepts Lite TS into C++17](todo), there was a lot of effort out there in the community to make a C++11 compatible implementation of Concepts, at least an emulation wrapping the usual SFINAE tricks.  
The point of Concepts is not the constraint syntax (which leads to pretty readable code but imho is not strictly necessary) but the hierarchical organization of different type concepts that had always been with us, but only as [documentation notes](http://en.cppreference.com/w/cpp/concept).

## Previous work

In this widespread C++ community, taking template meta-programming seriously introduces you into a very little niche of people as-crazy-as-you, currently leaded by what I call "The Gang Of Tmp": Louis Dionne, Paul Fultz II, and Eric Niebler. There are other players that are rising and I would like to see more of their work in the future, like Peter Dimov's series on Simple C++11 Meta-programming, and the amazing work from Philip RoseÃ© Forben on stateful meta-programming.

Anyone else noticed the fun fact that each one of the gang above has implemented his own version of a C++11 Concepts library? Fultz has [Fit](todo), [Boost.Hana](todo) has another one built in its internals, Niebler's range-v3 proposal is based heavily on Concept specification. We C++ers really have a serious problem on code sharing and dependency management... 

I have tried all those libs. Fit provides straightforward trait specification and checking, the best alternative for defining traits and concepts in your libraries these days: Just clone Fit into your include directories and you are ready. No dependencies, no headaches. I like range-v3 concepts since Niebler did a lot of work providing a wide set of concepts for the library. Almost any Standard Library concept is already defined there, plus the ones about ranges. Finally is Hana from Dionne: You really guys should try Boost.Hana. Hana is C++ The Right Way. Seriously. Concepts implementation in Hana are a mere implementation detail, but I'm confident Louis is currently working on modularizing the library, so it could be available as a standalone module in the future.

## The problem

One of the greatest gifts given by the Concepts Lite proposal is to reduce template diagnostic boilerplate when a concept is not satisfied: Instead of showing the whole "call stack" of instantiation failures, Concepts Lite will provide a meaningful message at the uppermost level:

{% highlight cpp %}

struct foo
{
	foo() = delete;
	foo(int) {}	
};

void f(const DefaultConstructible& e);

int main()
{
	f(foo{});
}

{% endhighlight %}

> **foo** does not satisfy the **DefaultConstructible** concept

Compare that to its SFINAE based alternative:

{% highlight cpp %}

template<typename T, 
         typename = typename std::enable_if<std::is_default_constructible<T>::value>::type>
void f(const T& e);

int main()
{
	f(foo{});
}

{% endhighlight %}

> No member named "type" in "std::enable_if<std::is_default_constructible<foo>::value>"

clang at least identifies this pattern and gives you something similar to "Specialization disabled by enable_if".

So far so good. But consider a more complex concept, one that's the aggregation of multiple properties and/or refines some other concepts. Take for example `TotallyOrdered` concept [from range-v3](todo):

{%highlight cpp %}
struct TotallyOrdered
  : refines<EqualityComparable, WeaklyOrdered>
{
    template<typename T>
    void requires_(T);

    template<typename T, typename U>
    auto requires_(T t, U u) -> decltype(
        concepts::valid_expr(
            concepts::model_of<TotallyOrdered>(val<T>()),
            concepts::model_of<TotallyOrdered>(val<U>())
        ));
};

struct foo {};

template<typename T, CONCEPT_REQUIRES(TotallyOrdered<T>())>
void f(const T& e);

int main()
{
	f(foo{});
}

{% endhighlight %}

`CONCEPT_REQUIRES()` macro will tell you that `foo` does not satisfy the `TotallyOrdered` concept, **but not why**. This issue was already noticed in the recent addition of Concepts Lite branch into GCC trunk. 

I noticed this problem writing a custom range type while playing with range-v3:

{% highlight cpp %}
struct MyRange
{
    struct Iterator{ ... };

    Iterator begin() const;
    Iterator end() const;
};

void odds_only(const MyRange& r)
{
    return r | ranges::view::filter([](int e)
    {
        return i % 2 == 0;
    });
}
{% endhighlight %}

I might made a mistake with the `Iterator` class since the internal concept checks that range has said that `MyRange` was not a range so I couldn't apply a view on it. *`MyRange` doesn't satisfy the "`Range`" concept*. But why? I had to deep dive into the range-v3 concepts hierarchy sources to figure out what was wrong with my iterators.

## When a C++ programmer is frustrated on X, writes yet another X library

That experience left me a bad taste. That wasn't fine, Niebler took a lot of work to get the concepts right, but a frustrated user could just throw away range-v3 at first chance if is not able to figure out what was wrong. 

The C++11 concepts implementations described above are focused on success, on passing the type across all the concept properties to look if those are fulfilled, grabbing out the result for SFINAEing functions, classes, etc. Those concepts are just functions computing a result.   

But what if we design concepts that are not mere sets of properties that should be true, but a bag of meta-information about this properties? 
Since the properties are formulated and checked at compile time, there should be a way to, when checking if a type `T` meets a concept `C`, collect enough information to give a meaningful error message to the user about what was wrong. That is, instead of just carrying boolean information about the application of `T` in `C`, also store information about **how `T` acted at each property of `C`**.

All the guys above have their own concepts checking library, I don't want to be 